package org.coffeebag.processor;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;

import org.coffeebag.domain.VisibilityInvariant;
import org.coffeebag.log.Log;
import org.coffeebag.processor.invariants.InvariantFinder;
import org.coffeebag.processor.references.ReferenceFinder;

@SupportedAnnotationTypes("*")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class CheckVisibility extends AbstractProcessor {
	private static final String TAG = CheckVisibility.class.getSimpleName();
	
	/**
	 * Preprocessor configuration
	 */
	public static class Config {
		public final boolean log;
		public final boolean recordTestData;
		/**
		 * Creates a new configuration
		 * @param log if the processor should output log information
		 * @param recordTestData if the processor should record information that is useful for testing
		 */
		public Config(boolean log, boolean recordTestData) {
			this.log = log;
			this.recordTestData = recordTestData;
		}
		private static final Config TEST_INSTANCE = new Config(true, true);
		/**
		 * Returns a configuration that enables logging and test data recording
		 * @return a test configuration
		 */
		public static Config test() {
			return TEST_INSTANCE;
		}
	}
	
	/**
	 * Maps from a class name to a set of canonical class/interface/enum names that it references
	 * 
	 * This is normally null. It is used in test mode to store results.
	 */
	private Map<String, Set<String>> typeReferences;
	
	/**
	 *
	 */
	private Map<Element, VisibilityInvariant> annotatedMemberToInvariant;
	
	/**
	 * Creates a new processor that does not log or record test data
	 */
	public CheckVisibility() {
		this(null);
	}

	/**
	 * Creates a new processor
	 * @param config a configuration, or null to use the default configuration. The default configuration is no logging
	 * and no test data recording.
	 */
	public CheckVisibility(Config config) {
		typeReferences = null;
		annotatedMemberToInvariant = new HashMap<>();
		
		if (config != null && config.log) {
			Log.getInstance().setEnabled(true);
		} else {
			Log.getInstance().setEnabled(false);
		}
		if (config != null && config.recordTestData) {
			typeReferences = new HashMap<>();
		}
	}
	
	@Override
	public boolean process(Set<? extends TypeElement> typeElements, RoundEnvironment roundEnv) {
		if (!roundEnv.processingOver()) {
			// build member usage structure
			for (Element element : roundEnv.getRootElements()) {
				final ReferenceFinder finder = new ReferenceFinder(processingEnv, element);
				final Set<String> usedTypes = finder.getTypesUsed();
				
				// Record if in test mode
				if (typeReferences != null) {
					typeReferences.put(element.asType().toString(), usedTypes);
				}

				StringBuilder message = new StringBuilder()
						.append("Element ")
						.append(element)
						.append(" used these types:");
				for (String used : usedTypes) {
					message.append("\n\t").append(used);
				}
				Log.d(TAG, message.toString());
			}

			// build visibility invariant structure
			for (Element element : roundEnv.getRootElements()) {
				InvariantFinder finder = new InvariantFinder(processingEnv, element);
				annotatedMemberToInvariant.putAll(finder.getVisibilityInvariants());
			}
		} else {
			// compare visibility invariants and their usages
			// processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, "error msg", element);
		}
		// Allow other annotations to be processed
		return false;
	}

	/**
	 * For testing, returns the referenced types that were detected
	 * @return the types analyzed and the types that they refer to
	 */
	Map<String, Set<String>> getTypeReferences() {
		return typeReferences;
	}

	/**
	 * For testing
	 * @return the invariants generated by the processor
	 */
	Map<Element, VisibilityInvariant> getInvariants() {
		return annotatedMemberToInvariant;
	}
}
