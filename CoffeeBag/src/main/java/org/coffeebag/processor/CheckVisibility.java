package org.coffeebag.processor;

import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic;

import org.coffeebag.domain.invariant.VisibilityInvariant;
import org.coffeebag.log.Log;
import org.coffeebag.processor.invariants.InvariantFinder;
import org.coffeebag.processor.references.ReferenceFinder;

@SupportedAnnotationTypes("*")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class CheckVisibility extends AbstractProcessor {
	private static final String TAG = CheckVisibility.class.getSimpleName();

	/**
	 * Preprocessor configuration
	 */
	public static class Config {
		public final boolean log;
		public final boolean recordTestData;

		/**
		 * Creates a new configuration
		 *
		 * @param log            if the processor should output log information
		 * @param recordTestData if the processor should record information that is useful for testing
		 */
		public Config(boolean log, boolean recordTestData) {
			this.log = log;
			this.recordTestData = recordTestData;
		}

		private static final Config TEST_INSTANCE = new Config(true, true);

		/**
		 * Returns a configuration that enables logging and test data recording
		 *
		 * @return a test configuration
		 */
		public static Config test() {
			return TEST_INSTANCE;
		}
	}

	/**
	 * Maps from a class name to a set of canonical class/interface/enum names that it references
	 * <p>
	 * This is normally null. It is used in test mode to store results.
	 */
	private Map<String, Set<String>> typeReferences;

	/**
	 * Maps a class's qualified name to its visibility invariant.
	 * If a class is not present in this mapping, it was not annotated
	 */
	private Map<String, VisibilityInvariant> annotatedMemberToInvariant;

	/**
	 * Creates a new processor that does not log or record test data
	 */
	public CheckVisibility() {
		this(null);
	}

	/**
	 * Creates a new processor
	 *
	 * @param config a configuration, or null to use the default configuration. The default configuration is no logging
	 *               and no test data recording.
	 */
	public CheckVisibility(Config config) {
		typeReferences = new HashMap<>();
		annotatedMemberToInvariant = new HashMap<>();

		if (config != null && config.log) {
			Log.getInstance().setEnabled(true);
		} else {
			Log.getInstance().setEnabled(false);
		}
	}

	@Override
	public boolean process(Set<? extends TypeElement> typeElements, RoundEnvironment roundEnv) {
		if (!roundEnv.processingOver()) {
			// build member usage structure
			for (Element element : roundEnv.getRootElements()) {
				final ReferenceFinder finder = new ReferenceFinder(processingEnv, element);
				final Set<String> usedTypes = finder.getTypesUsed();

				// Record if in test mode
				if (typeReferences != null) {
					typeReferences.put(element.asType().toString(), usedTypes);
				}

				StringBuilder message = new StringBuilder()
						.append("Element ")
						.append(element)
						.append(" used these types:");
				for (String used : usedTypes) {
					message.append("\n\t").append(used);
				}
				Log.d(TAG, message.toString());
			}

			// build visibility invariant structure
			InvariantFinder finder = new InvariantFinder();
			annotatedMemberToInvariant.putAll(finder.getVisibilityInvariants(roundEnv));
		} else {
			// compare visibility invariants and their usages
			for (Entry<String, Set<String>> typeReference : typeReferences.entrySet()) {
				for (String classUsage : typeReference.getValue()) {
					if (annotatedMemberToInvariant.containsKey(classUsage)) {
						TypeElement typeElement = processingEnv.getElementUtils().getTypeElement(classUsage);
						if (annotatedMemberToInvariant.get(classUsage).isUsageAllowedIn(typeElement)) {
							processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, "error msg", typeElement);
						}
					}
				}
			}
		}
		// Allow other annotations to be processed
		return false;
	}

	/**
	 * For testing, returns the referenced types that were detected
	 *
	 * @return the types analyzed and the types that they refer to
	 */
	Map<String, Set<String>> getTypeReferences() {
		return typeReferences;
	}

	/**
	 * For testing
	 *
	 * @return the invariants generated by the processor
	 */
	Map<String, VisibilityInvariant> getInvariants() {
		return annotatedMemberToInvariant;
	}
}
